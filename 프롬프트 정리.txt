genetic tree를 구현해줘. 아래의 명세를 모두 반영해야 한다.
- 해당 GA tree의 목적은 자동 트레이딩을 위한 코드이다.
- tree의 분기는 무조건 비교 구문으로 구성된다.
-- tree의 분기는 무조건 2개의 형식으로 구분된다.
--- 하나의 노드의 자식 노드는 여러개가 될 수 있다. (제한 없음)
--- feature >< number or feature1 >< feature2
--- 형식의 feature는 미리 지정해준다.
--- ex)   feature_num     = ['RSI', 'ATR', 'WR'] 
  feature_pair    = ['SMA', 'EMA', 'BB_upper','BB_lower']
--- 즉, 숫자와 비교하는 feature와 feature끼리 비교하는 feature들의 그룹을 미리 지정해줄 예정이다.
--- feature_num의 경우, 해당 데이터의 최대 및 최소 값도 같이 주어질 예정이다.
--- GA의 변이는 tree의 분기를 늘리거나 줄이거나 해당 분기를 위의 조건에 맞는 한에서 변경한다.
-- 트리의 root 바로 아래 노드는 3개의 노드가 존재하며, 각각 현재 포지션이 ['LONG', 'HOLD', 'SHORT']인지 구분한다.
--- crossover는 기존 트리에서 일정 부분의 branch 전체를 선택해서 crossover를 진행한다.
--- crossover되는 branch에 하위 branch가 존재한다면, 통째로 crossover가 된다.
--- 자식 노드가 여러개일 경우에는, 하나의 자식 노드만 충족해도 해당 자식 노드들의 모든 경우를 탐색한다.
---- 예를 들어 자식 노드 1, 2, 3이 있을 경우 1과 3의 경우가 충족되었다면, 1과 3의 tree로 진행한다.
--- 진행한 트리의 node가 해당 조건을 충족하지 않고, 멈춘다면, 행동은 hold이다.

--- 마지막 결과값은 진입 포지션(long, short), 진입 비중(0 ~ 1의 실수), 레버리지 배수(0 ~ 100의 정수) 값들이 나와야 한다.
--- 여러 leaf 노드에서 조건이 만족했다면, 가장 먼저 탐색을 완료한 결과로 진행한다.
--- 마지막 결과값도 변이가 가능하다.

--- 해당 노드들은 무조건 고정된 노드들이며, 변이되지 않는다. 즉, 가장 위의 노드들은 변경되어서는 안된다.

너가 이해한 내용을 정리해서 작성해봐

---------

좋아 정확하게 이해했어. 이제 해당 방법의 TREE를 코드로 작성하되, CUDA 및 C 코드에서도 쉽게 동작할 수 있는 코드로 작성해줘.
즉, 해당 TREE의 연산이 C 및 CUDA에서도 이루어질 수 있도록 작성해줘.
그 이유는 ga를 학습시키기 위해서 CUDA를 활용할 계획이다.
나의 계획에 대해 간략하게 설명하자면,
만약 수천 수만개의 TREE가 POP_SIZE로 존재할 경우, 이것을 CPU로 연산하기에는 매우 오래 걸린다.
따라서, CUDA를 활용하여, 스레드 하나마다 TREE를 배정하여, 병렬 연산을 진행하여 추론을 진행할 예정이다.
따라서, 해당 상황에서도 적절하게 동작할 수 있는 모델을 작성해야 한다.
아직, CROSSOVER 등 작성할 필요는 없고, 모델 부분만 작성을 해줘.
Tree에는 max_node와 max_depth가 존재해야 한다.
Tree에는 추가로 2가지 기능이 추가되어야 한다. 처음 Tree를 생성할 때, 조건에 맞는 랜덤 Tree 생성
그리고 load() method를 통해 저장된 Tree weight? node?를 불러올 수 있는 함수도 작성해줘.

비교 연산은 3가지만 존재한다. > < =


강조하는 것은 여기서 말하는 cuda 및 C 호환의 의미는 Model 자체를 Cuda로 만드는 것이 목적이 아니다.
예를 들어 GATree와 그것을 인구단위로 묶은 GATreePop이라는 python Class를 만들었을 때, GATreePop 자체가 c와 cuda에 입력으로 들어와 연산을 하는 것이 목적이다.
즉, c에서 담당할 부분은 python으로 들어온 객체를 cuda kernel에 넣을 수 있는 형태로 변환하는 기능
cuda에서 담당할 부분은 병렬적으로 모든 Tree의 추론을 진행.
이를 위해서는 미리 Tree의 데이터 정보들을 GPU에 올려놓을 수 있도록 Torch.Tensor를 사용하자(grad는 필요없으므로 False)

가장 대표적인 예시로 python Torch에서 선언된 Tensor를 setup 및 커스텀 c와 cuda 함수를 통해 연산을 하는 방식이라고 보면된다.
load에는 2가지 입력을 받을 수 있다. 파일 경로 혹은 torch의 state_dict
따라서 저장 역시 torch의 state_dict 형식으로 저장하고, 해당 tree의 모든 정보를 저장해야 한다.

일단 코드 작성하지 말고 너가 이해한 내용을 먼저 정리해봐.
매우 많은 요구사항이기 때문에, 빠짐없이, 매우 자세하게 분석 후 정리해야 한다.